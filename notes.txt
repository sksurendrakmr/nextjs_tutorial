React Server Components (RSC)
--
React server components is a new architecture introduced by the React team in version
18 which was quickly embraced by Next.js

The architecture introduces a new way of creating React components, splitting them into 
two types:
 - Server components
 - Client components


 Server components
 ---
 - In Next.js, all components are server components by default.
 - They have the ability to run tasks like reading files or fetching data from a database.
 - However, they don't have the ability to use hooks or handle user interactions.

 Client components
 ---

 - To create a client component, it's necessary to add "use client" at the top of the component file
 - Client components can't perform tasks like reading files, but they have the ability to use hooks and manage interactions.



 Routing
 ---
 Next.js has a file system based routing mechanism.

 URL paths that users can access in the browser are defined by files and folders in our codebase.

 Next.js is a file based routing mechanism but does that mean every file in our app corresponds to a route?? --> NO

 Routing conventions
 ---
 All routes must be placed inside the app folder.
 Every file that corresponds to a route must be named page.js or page.tsx.
 Each folder corresponds to a path segment in the browser URL.

Notes: Route is associated with file based on the containing folders name within the 
app folder.

By creating a nested folder structure, files will automatically be routed in the same
way within the URL.

Private folders
---
A private folder indicates that it is a private implementation detail and should not be
considered by the routing system

The folder and all its subfolders are excluded from routing.

Prefix the folder name with an underscore.

Use for 
- For separting UI logic from routing logic 
- For consistently organizing internal files across a project.
- For sorting and grouping files in code editor.
- For avoiding potential naming conflicts with future Next.js file conventions.

If we want to include an underscore in URL segments, we can prefix the folder name "%5F", which is the URL-encoded form of an underscore.

Route Groups
---
Allows us to logically group our routes and project files without affecting the URL path structure.

Organize routes and project files into groups based on sections or intent.

Route group -> we can mark the folder as route group to exclude it to route URL path

By wrapping the folder name within parenthesis, we informing nextjs that auth folder
will be treated as route group and its name will be omitted from the URL path. 

Layouts
---
A page is UI that is unique to a route.
A layout is UI that is shared between multiple pages in the app.

How to create Layouts
---
we can define a layout by default exporting a react component from a layput.js or layout.tsx file.
That component should accept a children prop that will be populated with a child page 
during rendering.

Nested layout
----
Layouts can be nested.
If we want to create a layout specifically for a route, we can create layout.tsx file 
withing that folder.      

Route Group Layout
---

Route group uses:
---
To organize the project in a manner that doesn't affect the URL.
To selectively apply a layout to certain segments while leaving others unchanged.


Routing Metadata
---

Ensuring proper search engine optimization (SEO) is crucial for increasing visibility
and attracting users.

Next.js introduced the Metadata API which allows us to define metadata for each page.

Metadata ensures accurate and relevant information is displayed when our pages are shared or indexed.

Configuring Metadata
---
Export a static metadata object.
Export a dynamic generateMetadata function

Metadata rules
---
Both layout.tsx and page.tsx files can export metadata. If defined in a layout, it applies to all pages in that layout, but if defined in a page, it applies only to that page.


Metadata is read in order, from the root level down to the final page level.

When there's metadata in multiple places for the same route, they get combined but page metdata will replace layout metadata if they have the same properties.

Dynamic metadata depends on dynamic information such as the current route parameters,
external data or metadata in parent segments.

To define dynamic metadata, we export a generateMetadata() that returns a metadata object from a layout or page.tsx file. 

title Metadata
---
The title field's primary purpose is to define the document title.
It can be either a string or an object.


Navigation
---
To enable client-side navigation, Nextjs provides us with the Link component

The <Link> component is a React component that extends the HTML `<a>` element, and it's 
the primary way to navigate between routes in Nextjs

To use it, we need to import it from "next/link"


Template
---
The layouts only mount the part representing the content of the newly loaded page 
but keep all the common elements untouched.
Layout doesn't remount shared components resulting in better performance.

In majority of the time, we need this scenario.
However, we might come across a scenari where we need the layouts to create a new 
instance for each of their children on navigation.

In such situation, we will use the template file as replacement of the layout file.

Templates are similar to layouts in that they wrap each child layout or page.
But, with templates, when a user navigates between routes that share a template, a new instance of the component is mounted. DOM elements are recreated, state is not preserved, and effects are re-synchronized

A template can be defined by exporting a default React component from a template.js or template.tsx file.

Similar to layouts, tempaltes also should accept a children prop which will render the nested segments in the route.

It is possible that layout and template co-exist.
In such scenario, Layout renders first and the layout's children is replaced by the component exported from the template file.


Loading UI
---

loading.tsx 
--
This file allows us to create loading states that are displayed to users while a specific route segment's content is loading.

The loading state appears immediately upon navigation, giving users the assurance that the application is responsive and actively loading content.


Handling Errors in Nested routes
---
Errors bubble up to the closest parent error boundary.
This implies that an error.tsx file will cater to errors for all its nested child segments.

By positioning error.tsx files at different levels in the nested folders of a route, we can achieve a more granular level of error handling.


Handling errors in Layouts
---
An error.tsx file will handle errors for all its nested child segments.

The error boundary does not catch errors thrown here because it's nested inside the layout component.

we should keep the error.tsx file in the same directory as layout


Parallel Routes 
---
Parallel routes are an advanced routing mechanism that allows for the simultaneous rendering of multiple pages within the same layout.


Intercepting Routes 
---
Intercepting routes allow us to intercept or stop the default routing behaviour to present an alternate view or component when navigating through the UI, while still preserving the indended route for scenarios like page reloads.

This can be usefule if we want to show a route while keeping the context of the current page.

